# 算法Day3 - 不定长滑动窗口/最长不同字符子串
- 把数组或字符串想象成一个可左右移动的“窗口”，窗口内的元素是需要处理的数据，通过移动窗口的右边界来扩展窗口，通过移动窗口的左边界来收缩窗口，从而动态地寻找满足条件的子数组或子串。

## 要点一：滑动窗口更好还是双指针？
滑动窗口是更准确、更常用的**解题思路**，而双指针是实现滑动窗口的一种具体技术。

## 要点二：核心思路？
python用集合记录窗口内不同的字符：
1. right 指针负责扩展窗口：right 指针会一直向右移动，不断尝试将新的字符加入窗口。
2. left 指针负责收缩窗口：如果 right 指针指向的字符已经在 char_set 中了，说明出现了重复。此时，我们就需要移动 left 指针来收缩窗口，直到重复的字符被移出窗口。
3. 更新最大长度：每当窗口中的字符都不重复时，我们都会计算当前窗口的长度 (right - left + 1)，并用它来更新最终的最大长度。

### 疑点：为什么移除左边界的字符啊，难道不会删错吗？/ 为什么还会把a踢出去啊，不应该只踢b吗?
1. 移除**字符集合**里的在原字符串中重复的字符，而**不是在原字符串**本体移除掉。
2. 之所以移除 'a'，不是因为 'a' 是重复的，而是**因为它是窗口的最左侧字符**。
3. 当 right 指针遇到重复时，我们不知道重复的字符在窗口的哪个位置，但我们知道**只要从左边开始收缩窗口，迟早会把重复的字符挤出去**。
4. 此算法并不是把所有可能的子串都塞入到窗口和集合里。

## 复杂度
#### 时间复杂度：平均/总体为 O(n)。
解释：right 指针从左到右各位置最多访问一次；left 指针同样只会单调右移，每个字符最多被加入和移除集合各一次。while 循环虽然在某些步里多次执行，但总执行次数不超过 n，因此摊还为 O(n)。
#### 空间复杂度：O(min(n, Σ))。
解释：char_set 保存当前窗口内的不重复字符，大小最多为字符串长度 n，但也受限于字符集大小 Σ（例如 ASCII 为常数 128/256）。因此空间上界为两者的较小值。在常量大小字符集下可视为 O(1)；一般情况下写作 O(n)。

# 代码示例
## python
```python
def lengthOfLongestSubstring(self, s: str) -> int:
    char_set = set()
    left = 0
    max_len = 0
    for right in range(len(s)):
        currentChar = s[right]
        while currentChar in char_set:
            char_set.remove(s[left])
            left += 1
        char_set.add(currentChar)
        max_len = max(max_len, right - left + 1)
    return max_len
```